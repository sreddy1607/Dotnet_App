/*
=======================================================================================
This file is being updated constantly by the DevOps team to introduce new enhancements
based on the template.  If you have suggestions for improvement,
please contact the DevOps team so that we can incorporate the changes into the
template.  In the meantime, if you have made changes here or don't want this file to be
updated, please indicate so at the beginning of this file.
=======================================================================================
*/

def branch = env.BRANCH_NAME ?: "Dev"
def workingDir = "/home/jenkins/agent"

pipeline {
  agent {
    kubernetes {
      yaml """
        apiVersion: v1
        kind: Pod
        spec:
          serviceAccountName: jenkins
          volumes:
            - name: dockersock
              hostPath:
                path: /var/run/docker.sock
            - emptyDir: {}
              name: varlibcontainers
            - name: jenkins-trusted-ca-bundle
              configMap:
                name: jenkins-trusted-ca-bundle
                defaultMode: 420
                optional: true
          containers:
            - name: dotnet
              image: 136299550619.dkr.ecr.us-west-2.amazonaws.com/cammismspapp:1.0.34
              tty: true
              command: ["/bin/bash"]
              securityContext:
                privileged: true
              workingDir: ${workingDir}
              envFrom:
                - configMapRef:
                    name: jenkins-agent-env
                    optional: true
              env:
                - name: HOME
                  value: ${workingDir}
                - name: BRANCH
                  value: ${branch}
            - name: jnlp
              securityContext:
                privileged: true
              envFrom:
                - configMapRef:
                    name: jenkins-agent-env
                    optional: true
              env:
                - name: GIT_SSL_CAINFO
                  value: "/etc/pki/tls/certs/ca-bundle.crt"
              volumeMounts:
                - name: jenkins-trusted-ca-bundle
                  mountPath: /etc/pki/tls/certs
            - name: node
              image: registry.access.redhat.com/ubi8/nodejs-18:latest
              tty: true
              command: ["/bin/bash"]
              securityContext:
                privileged: true
              workingDir: ${workingDir}
              securityContext:
                privileged: true
              envFrom:
                - configMapRef:
                    name: jenkins-agent-env
                    optional: true
              env:
                - name: HOME
                  value: ${workingDir}
                - name: BRANCH
                  value: ${branch}
                - name: GIT_SSL_CAINFO
                  value: "/etc/pki/tls/certs/ca-bundle.crt"
              volumeMounts:
                - name: jenkins-trusted-ca-bundle
                  mountPath: /etc/pki/tls/certs
            - name: aws-boto3
              image: 136299550619.dkr.ecr.us-west-2.amazonaws.com/cammisboto3:1.0.1
              tty: true
              command: ["/bin/bash"]
              workingDir: ${workingDir}
              envFrom:
                - configMapRef:
                    name: jenkins-agent-env
                    optional: true
              env:
                - name: HOME
                  value: ${workingDir}
                - name: BRANCH
                  value: ${branch}
                - name: GIT_SSL_CAINFO
                  value: "/etc/pki/tls/certs/ca-bundle.crt"
              volumeMounts:
                - name: jenkins-trusted-ca-bundle
                  mountPath: /etc/pki/tls/certs
      """
    }
  }

  options {
    timestamps()
    disableConcurrentBuilds()
    timeout(time:5 , unit: 'HOURS')
    skipDefaultCheckout()
    buildDiscarder(logRotator(numToKeepStr: '20'))
  }

  environment {
    env_current_git_commit=""
    env_accesskey=""
    env_secretkey=""
    env_tag_name=""
    env_deploy_env=""
    env_skip_deploy="true"
    env_DEPLOY_ENVIRONMENT="false"
    env_DEPLOY_FILES="true"
    env_DEPLOY_CONFIG="false"
    env_release_type=""
  }

  stages {
   stage("Initialize") {
      steps {
        container(name: "node") {
          script {

            properties([
              parameters([
                choice(name: 'RELEASE_TYPE', choices: ['PATCH','MINOR','MAJOR'], description: 'Enter Release type'),
                booleanParam(name: 'USE_GIT_TAG', defaultValue: false, description: 'Use the selected git tag instead of LATEST commit'),
                gitParameter(name: 'GIT_TAG', defaultValue: 'tar-surge-client_from_dev', description: 'git tag', type: 'PT_TAG'),
                string(name: 'GIT_SHA',defaultValue: 'enter git sha(8+ chars)', description: 'enter git sha that you want to deploy') 
              ])
            ])

            deleteDir()

            env_release_type = params.RELEASE_TYPE
            echo 'checkout source  and get the commit id'
            env_current_git_commit = checkout(scm).GIT_COMMIT

            // get the short version of commit
            env_current_git_commit="${env_current_git_commit[0..7]}"

            env_deploy_env = "DEV"

            echo "Current deployment environment is ${env_deploy_env}"

            env_tag_name = "${branch}_${BUILD_NUMBER}_${env_current_git_commit}"

            if (params.USE_GIT_TAG == true) {
              env_current_git_commit = params.GIT_TAG
            }

            if ( ! params.GIT_SHA.contains("enter") ) {
              env_current_git_commit = params.GIT_SHA
            }

            echo "Tag to be applied is: ${env_tag_name}"
            echo "Tag will be applied to: ${env_current_git_commit}"
            
            def repositories = [
                        [name: 'tar-surge-client', branch: 'master', url: 'https://github.com/ca-mmis/tar-surge-client.git'],
                        [name: 'tar-surge-app', branch: 'master', url: 'https://github.com/ca-mmis/tar-surge-app.git']
                    ]

                    repositories.each { repo ->
                        dir(repo.name) {
                            git branch: repo.branch, credentialsId: 'github-key', url: repo.url
                        }
                    } 

            if ( ( params.GIT_SHA.contains("enter")) && (params.USE_GIT_TAG == false)) {
              // use latest commit to build and deploy to DEV
              withCredentials([usernamePassword(credentialsId: "github-key", usernameVariable: 'NUSER', passwordVariable: 'NPASS')]) {
                sh """#!/bin/bash
                  git config --global --add safe.directory '*'
                  git config --system --add safe.directory '*' 
                  echo "The commit hash from the latest git current commit is ${env_current_git_commit}"
                  echo "The current build number is: ${BUILD_NUMBER}"
                  echo "The current branch is: ${branch}"
                  tagMessage="${env_tag_name}"
                  git checkout \${branch}
                  echo "Checked out ${branch}"
                  git config  --global user.email "jenkins@cammis.com"
                  git config  --global user.name "jenkins"
                  echo "The tagMessage is \$tagMessage"
                  echo "About to fetch"
                  git fetch --quiet --tags https://${NUSER}:${NPASS}@github.com/ca-mmis/tar-surge-client.git
                  echo "About to tag commit with build and branch"
                  git tag -f -a "\$tagMessage" -m "tag build" ${env_current_git_commit}
                  echo "About to push tag"
                  git push -f https://${NUSER}:${NPASS}@github.com/ca-mmis/tar-surge-client.git \$tagMessage
                  echo "Push is done"
                  echo "Checking out selected commit"
                  git checkout ${env_current_git_commit}
                  git show --stat ${env_current_git_commit} > commit-changes.txt
                  echo "START OF FILES CHANGED"
                  cat commit-changes.txt
                  echo "END OF FILES CHANGED"
                  echo "Checkout out ${env_current_git_commit}"
                  """
              }
            } else if ( (params.USE_GIT_TAG == true) || ( ! params.GIT_SHA.contains("enter")) ) {
  			      // using a git tag or git sha, ${env_current_git_commit}" is now the commit tag selected or git sha entered
              withCredentials([usernamePassword(credentialsId: "github-key", usernameVariable: 'NUSER', passwordVariable: 'NPASS')]) {
                sh """#!/bin/bash
                  echo "Checking out SHA or TAG: ${env_current_git_commit}"
                  git config --global --add safe.directory '*'
                  git config --system --add safe.directory '*' 
                  git checkout \${env_current_git_commit}
                  echo "Since this is a previous commit, need to rebuild everything"
                  echo "Cammis.Surge.Client" > commit-changes.txt
                  echo "Cammis.Surge.RPM.App" >> commit-changes.txt
                  echo "Cammis.Surge.SharedClient" >> commit-changes.txt
                  cat commit-changes.txt
                  echo "Checked out ${env_current_git_commit}"
                  """
              }
            } 
          } //END script
        } //END container node
      } //END steps
    } //END stage

  stage('Build') {
    steps {
      container("dotnet") {
        script {
          sh '''
            echo "Building thick client..."
            mkdir -p devops/codedeploy/SurgeUpdate
            dotnet publish tar-surge-client/Cammis.Surge.Client.sln \
              -o build_output -c Release -r win-x64 --self-contained true /p:EnableWindowsTargeting=true
          '''
        
          def exeVersion = "0.0.${BUILD_NUMBER}"
        
        // Copy build + configs
          sh """
            cp -r build_output/* devops/codedeploy/SurgeUpdate/
            cp tar-surge-client/Config/${env_deploy_env}/* devops/codedeploy/SurgeUpdate/
          
            cd devops/codedeploy
            zip -r SurgeUpdate/SurgeUpdate_${env_deploy_env}.ZIP SurgeUpdate
          """
        }
      }
    }
  }


stage('Sonar Scan') {
      when {
        expression {
          env_DEPLOY_FILES == "true"
        }
      }
      steps {
        container(name: "dotnet") {
          script {
            sh """#!/bin/bash
		      set +e
                      echo 'Sonar Scan Stage....\n\n'
                
		              cd  tar-surge-client/Cammis.Surge.Client
	                  dotnet tool install dotnet-sonarscanner --global
		              export PATH="$PATH:/home/jenkins/agent/.dotnet/tools"
		              dotnet sonarscanner begin /key:"tar-surge-client" /d:sonar.host.url="http://sonarqube-tools.apps.bld.cammis.medi-cal.ca.gov"
                      dotnet publish /p:EnableWindowsTargeting=true
                      dotnet sonarscanner end   
              """
          }
        }
      }
    }
	  
 stage('Deploy') {
      steps {
        lock(resource: 'codedeploy-ec2-lock') {
          container("aws-boto3") {
            script {
              echo "Deploy Using AWS CodeDeploy..."
              withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr-ecs', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
              step([$class: 'AWSCodeDeployPublisher',
                  applicationName: "tar-surge-app-${env_deploy_env}",
                  awsAccessKey: "${AWS_ACCESS_KEY_ID}",
                  awsSecretKey: "${AWS_SECRET_ACCESS_KEY}",
                  credentials: 'awsAccessKey',
                  deploymentConfig: "tar-surge-app-${env_deploy_env}-config",
                  deploymentGroupAppspec: false,
                  deploymentGroupName: "tar-surge-app-${env_deploy_env}-INPLACE-deployment-group",
                  deploymentMethod: 'deploy',
                  excludes: '', iamRoleArn: '', includes: '**', pollingFreqSec: 15, pollingTimeoutSec: 900, proxyHost: '', proxyPort: 0,
                  region: 'us-west-2', s3bucket: 'dhcs-codedeploy-app', 
                  subdirectory: 'devops/codedeploy', versionFileName: '', waitForCompletion: true])
              }
            }
          }
        }
        container(name: "jnlp") {
          lock(resource: 'deployments-github-repo',inversePrecedence: false ) {
           dir("${WORKSPACE}/deployrepo"){
              withCredentials([usernamePassword(credentialsId: "github-key", usernameVariable: 'NUSER', passwordVariable: 'NPASS')]) {
                sh """
                  git clone https://${NUSER}:${NPASS}@github.com/ca-mmis/deployments-combined-devops.git --depth=1
                  git config  --global user.email "jenkins@cammis.com"
                  git config  --global user.name "jenkins"

                  cd deployments-combined-devops
                  git checkout master
                  git pull

				  # Prepare folders
					  mkdir -p ${WORKSPACE}/deployrepo/deployments-combined-devops/SurgeAutoupdate/dev/SurgeUpdate
					  rm -rf SurgeAutoupdate/dev/SurgeUpdate/*

					 echo "Removing BAT script from SurgeUpdate before zipping..."
					  rm -f ${WORKSPACE}/devops/codedeploy/SurgeUpdate/SurgeInstall_${env_deploy_env}.bat || true
						
					  echo "Recreating ZIP again without BAT script..."
					  cd ${WORKSPACE}/devops/codedeploy
					  rm -f SurgeUpdate/SurgeUpdate_${env_deploy_env}.ZIP
					  zip -r SurgeUpdate/SurgeUpdate_${env_deploy_env}.ZIP SurgeUpdate
						
					  echo "Copying ZIP to deployed combined repo"
					  cp ${WORKSPACE}/devops/codedeploy/SurgeUpdate/SurgeUpdate_${env_deploy_env}.ZIP SurgeAutoupdate/dev/SurgeUpdate/
					
					  # Commit and push
					  git add .
					  git commit -m "Updated build artifacts for tar-surge-client build ${env_tag_name}" || true
					  git push https://${NUSER}:${NPASS}@github.com/ca-mmis/deployments-combined-devops.git
					  
                """

                sh """
                  # Clone tar-surge-client-deployment repo
		              git clone https://${NUSER}:${NPASS}@github.com/ca-mmis/tar-surge-client-deployment.git --depth=1
		              cd tar-surge-client-deployment
		              git checkout master
		              git pull
	              
		              mkdir -p ${WORKSPACE}/deployrepo/tar-surge-client-deployment/tar-surge-client/SurgeAutoupdate
						
					  echo "Copying ZIP and BAT script separately..."
		              
		              cp ${WORKSPACE}/devops/codedeploy/SurgeUpdate/SurgeUpdate_${env_deploy_env}.ZIP tar-surge-client/SurgeAutoupdate
		              cp ${WORKSPACE}/devops/codedeploy/SurgeUpdate/SurgeInstall_${env_deploy_env}.bat tar-surge-client/SurgeAutoupdate
		
		              # Commit and push changes
		              if [[ -n \$(git status --porcelain) ]]; then
		                git add .
		                git commit -m "Automated commit - Deploying SurgeUpdate artifacts"
		                git push origin master
		              fi
		
		              # Tag this deployment
		              git tag -f -a "${env_tag_name}" -m "Deploying Thickclient - Tag ${env_tag_name}"
		              git push origin "${env_tag_name}" --force
					  
                """
              } //end withCredentials
            } //end dir
          } //end lock
        }  //end container
		  
      }
    }
  }

  post {
    always { echo "Build Process complete." }
    success { echo "Build and Deploy succeeded." }
    failure { echo "Build or Deploy failed." }
    aborted { echo "Build aborted." }
  }
}
