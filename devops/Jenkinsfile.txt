/*
=======================================================================================
This file is being updated constantly by the DevOps team to introduce new enhancements
based on the template for ngnix apps.  If you have suggestions for improvement,
please contact the DevOps team so that we can incorporate the changes into the
template.  In the meantime, if you have made changes here or don't want this file to be
updated, please indicate so at the beginning of this file.
=======================================================================================
*/

    
/*
naming convention:
    APP_NAME - all cap variables are either from Jenkinsfile.properties or jenkins built-in variables
               or pipeline parameters.
    g_stage_index - variables starting with "g_" are global variables declared in this file
    env_git_branch_type - variables starting with "env_" are declared in the environment section
*/


// Useful commands that can used.
//prev_merge=$(git log |grep -C1 Merge | grep commit |head -n1 | awk {'print $2'})
//commit=$(git log |head -n 1  | awk {'print $2'})
//git diff --name-only $prev_merge $commit
//git whatchanged origin/master -n 1
//git diff --name-only HEAD HEAD~1

//aws ecr list-images --repository-name cammiscloud --max-items 1
//aws ecr list-images --repository-name cammiscloud --max-items 1 | jq  .imageIds[].imageTag | tr -d '"'
//1.13
//aws ecr describe-images --repository-name cammiscloud --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' | tr -d '"'
//aws ecr describe-images --repository-name cammissample --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[1]' | tr -d '"'

//this points to the current type of environment the build is supposed to be deployed and tested.
//BRANCHES[env_git_branch_type].stages[g_stage_index]
//should be part of environment. but env variables can't be integer
//g_stage_index=1
//g_my_docker_image=null
//namespace array for an env type
//g_namespaces=[]
g_results=[]

def NEWSECRET
node {
 withCredentials([string(credentialsId: 'GitHub-Token', variable: 'NEWSECRET')]) { //set SECRET with the credential content
    echo "My secret from Node '${NEWSECRET}'"
    
  }
}
pipeline {
  agent {
    kubernetes {
      yamlFile "devops/kubePodTemplate.yaml"
    }
  }
 
  environment {
    AWS_DEFAULT_REGION="us-west-2"
    env_environment=""
    env_action=""
    env_release_type=""
    env_full_version=""
    env_relType=""
    env_versions=""
    env_version_data=""
    env_versionList=""
    env_git_branch_name=""
    env_current_git_commit=""
    env_git_repo_url=""
    env_stage_name=""
    env_step_name=""
    env_git_tag_name="Initial"
    env_cluster_subdomain="${CLUSTER_SUBDOMAIN}"
    
    env_cammiscloud=""
    env_cammisbuildah=""
    env_cammissample=""
    env_dotnetsample=""
    env_cammisboto3=""
  }

 stages {
    stage("initialize") {
      steps {
        container(name: "jnlp") {
          script {
           withCredentials([string(credentialsId: 'GitHub-Token', variable: 'SECRET')]) { //set SECRET with the credential content
            echo "My secret text is '${SECRET}'"
            
            // if you modify anything in the choice parameter be mindful of the fact that you might have to approve the new
            // scripts in manage jenkins - in-process script approval
            //echo "env_versionList: ${env_versionList}"
            //echo "g_results: ${g_results}"          
            properties([
              parameters([
                  booleanParam(name: 'dotnetsample', defaultValue: false, description: 'Use this option to build and push the testapp Container'),
                 //booleanParam(name: 'cammiscloud', defaultValue: false, description: 'Use this option to build and push the cammiscloud Container'),
                 //booleanParam(name: 'cammisbuildah', defaultValue: false, description: 'Use this option to build and push the cammisbuildah Container'),
                 //booleanParam(name: 'cammisterraform', defaultValue: false, description: 'Use this option to test changes to the jenkinsfile - build and push the cammisterraform Container'),
                 // booleanParam(name: 'cammissample', defaultValue: false, description: 'Use this option to test changes to the jenkinsfile - build and push the cammissample Container'),
                 // booleanParam(name: 'cammisboto3', defaultValue: false, description: 'Use this option to test changes to the jenkinsfile - build and push the cammisboto3 Container'),

                  [$class: 'CascadeChoiceParameter', 
                    choiceType: 'PT_SINGLE_SELECT', 
                    description: 'Select the Release Type from the Dropdown List',
                    name: 'RELEASE_TYPE',  
                    script: 
                      [$class: 'GroovyScript', 
                      fallbackScript: [
                        classpath: [], 
                        sandbox: true, 
                        script: "return['No Param Available of this operation - RELEASE_TYPE']"
                      ], 
                      script: [
                        classpath: [], 
                        sandbox: true, 
                        script: """
                          return["PATCH:selected","MINOR","MAJOR"]
                        """
                      ] 
                    ]
                  ],
                  [$class: 'DynamicReferenceParameter', 
                    choiceType: 'ET_ORDERED_LIST', 
                    description: 'Current versions', 
                    name: 'Current versions',  
                    script: 
                      [$class: 'GroovyScript',
                        sandbox: true, 
                        script: 'return["Could not find configurations"]', 
                        script: [
                          script: """
                            def urlrv = "curl -s https://${SECRET}@raw.githubusercontent.com/ca-mmis/combined-devops-jenkins-dockerfiles/master/devops/versions.txt"
                            def procrv = urlrv.execute();
                            def outputStreamrv = new StringBuffer();
                            procrv.waitForProcessOutput(outputStreamrv, System.err);
                            datarv = outputStreamrv.toString();
                            def listrv = datarv.readLines();
                            return listrv 
                          """                          
                        ]
                      ]
                  ]
              ])
            ])
             
            env_stage_name = "initialize" 
            env_step_name = "checkout"
           
            deleteDir()

            echo 'checkout source and get the commit id'
            env_current_git_commit = checkout(scm).GIT_COMMIT
            echo "env_current_git_commit =>${env_current_git_commit}<-"

            env_git_repo_url = sh(returnStdout: true, script: 'git config remote.origin.url').trim()
            echo "env_git_repo_url =>${env_git_repo_url}<-"

            echo 'Loading properties file'
            env_step_name = "load properties"
            // load the pipeline properties
            load("devops/Jenkinsfile.properties")

            echo "The cluster subdomain is ${env_cluster_subdomain}"

            env_step_name = "set global variables"
            echo 'initialize slack channels and tokens'
        //    initSlackChannels()

            echo 'set branch name'
            env_git_branch_name = "master"

            //env_tag_only=ECR_TAG_ONLY
            //env_dry_run=DRY_RUN
            //env_cammiscloud=params.cammiscloud
            //env_cammisbuildah=params.cammisbuildah
           // env_cammissample=params.cammissample
            //env_cammisterraform=params.cammisterraform
           // env_cammisboto3=params.cammisboto3
            env_dotnetsample=params.dotnetsample

            if (params.USE_GIT_TAG) {
              env_git_tag_name = params.GIT_TAG
            }

            if (params.RELEASE_TYPE) {
              // Release type - New/Rebuild
              env_release_type=params.RELEASE_TYPE
            }

            //set default image name space
            //change it to SANDBOX_IMAGE_SPACE if it's a feature branch
            env_image_namespace=NON_SANDBOX_IMAGE_SPACE

            //override release name
            if ( ! params.RELEASE == "" )
                RELEASE_NAME=params.RELEASE_TYPE

            // get the short version of commit
            env_current_git_commit="${env_current_git_commit[0..7]}"
            echo "env_current_git_commit =>${env_current_git_commit}<-"

            //include commit id in build name
            currentBuild.displayName = "#${BUILD_NUMBER} --- ${env_current_git_commit}"

            //set the values for the initial environment for deployment and tests
            
      //      slackNotification("pipeline","${APP_NAME}-${env_git_branch_name}: <${BUILD_URL}console|build #${BUILD_NUMBER}> started.","#439FE0","false")
           } // End With
          } //END script
        } //END container
      } //END steps
    } //END stage
    
    stage('build dotnetsample') {
      when {
        expression {
          params.dotnetsample == true
        }
      }
      steps {
        container(name:"buildah") {
          script {
            env_stage_name = 'build dotnet sample app image'
            env_step_name = "build"
            env_relType=params.RELEASE_TYPE
            
            withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {

              //login in the ecr
              sh """
                aws ecr get-login-password --region us-west-2 | buildah login --authfile ./auth.json -u AWS --password-stdin 136299550619.dkr.ecr.us-west-2.amazonaws.com
                cat ./auth.json
              """  
            
              // get version info.
              def version= sh returnStdout: true, script: "aws ecr describe-images --repository-name dotnetsample --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' | tr -d '\n' "
              
              version = version.toString().replaceAll('\\"','')	
              if ( version == "latest" ) {
                echo "version before : ${version}"
                version= sh returnStdout: true, script: "aws ecr describe-images --repository-name dotnetsample --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[1]' | tr -d '\n' "
                version = version.toString().replaceAll('\\"','')	
                echo "version after: ${version}"
              }
              
              if ( version == "null" ) {
                env_full_version="1.0.0" 
              }else {
                echo "version: ${version}"
                //version = version.toString().replaceAll('\\"','')	
                //echo "version: ${version}"
                def (major, minor, patch) = version.tokenize('.')
                
                if (patch == null && minor != "") {
                  patch = minor
                  minor = 0  
                }
                              
                def int newPatch = patch.toInteger();
                def int newMinor = minor.toInteger();
                def int newMajor = major.toInteger();
            
                if(env_relType == "PATCH" ) {
                  newPatch = newPatch+1
                } else if (env_relType == "MINOR") {
                  newMinor = newMinor+1
                  newPatch = 0
                } else if (env_relType == "MAJOR") {
                  newMajor = newMajor+1
                  newMinor = 0
                  newPatch = 0
                }
                env_full_version=newMajor+'.'+newMinor+'.'+ newPatch
              
              }
              APP_IMAGE="${IMAGE_REGISTRY}/dotnetsample:${env_full_version}"
              echo "APP_IMAGE: ${APP_IMAGE}"
            
              APP_LATEST="${IMAGE_REGISTRY}/dotnetsample:latest"
              echo "APP_LATEST: ${APP_LATEST}"
            
              // Tag containers prior to push
              sh """
                echo "Building image"
                #buildah --storage-driver vfs bud --tls-verify="false" --authfile ./auth.json --format=docker -f dotnetsample/Dockerfile -t ${APP_LATEST} -t ${APP_IMAGE} .
                buildah --storage-driver vfs bud --tls-verify="false" --authfile ./auth.json --format=docker -f dotnetsample/Dockerfile -t ${APP_IMAGE} .
                buildah --storage-driver vfs images -a
              
              """

              sh """
                echo "Show images"
                buildah --storage-driver vfs images --digests
              """
              // Added Cammis - Outside of shell
              echo "Building def"
            
              // Push to container to ECR
              sh """
                echo Buildah push
                echo "IMAGE_REGISTRY: ${IMAGE_REGISTRY}"
                buildah --storage-driver vfs push --tls-verify="false" --authfile ./auth.json "${APP_IMAGE}"
                #buildah --storage-driver vfs push --tls-verify="false" --authfile ./auth.json "${APP_LATEST}"
                aws ecr list-images --repository-name dotnetsample

                sleep 15
              """
             
            }  // End With
          }  //Script
        } // end container
        container(name:"awscli") {
          script {
            env_step_name = "pull vulnerability report"
            //env_image_fullspec="${env_image_namespace}/cammidotnetsamplessample"
            env_image_fullspec="dotnetsample"
            echo "env_image_fullspec = ${env_image_fullspec}"
            getVulnerabilityInfo(env_image_fullspec,env_full_version)
          }
        }  // END Container awscli
        container(name:"jnlp") {
          script {
            echo "send slack message"
            // env_step_name = "tag"
            // slackNotification("pipeline","${APP_NAME}-${env_git_branch_name}: <${BUILD_URL}console|build #${BUILD_NUMBER}> published to ECR.","#31C624","false")      
          }  // END Script
        }  // END Container
        
        
      }  // End Steps
    } // END Stage  

    stage('Update Versions') {
      when {
        expression {
          params.dotnetsample == true || params.cammissample == true || params.cammiscloud == true || params.cammisbuildah == true || params.cammisterraform == true || params.cammisboto3 == true
        }
      }
      steps {
        container(name:'awscli') {
          script { 
            withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            
              getallversions()
              
            } // END withCredentials
          }  // END Script
        } // END Container
        
        container(name:'jnlp') {
          script {    
              withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
              
                writeversioninfo()
               
              }  // END With
          }  // END Script
        }  // END Container
      }  // END Step
    }  // END Stage  
  }  // END Stages
} // END Pipeline 
  
//set slack channels and tokens
def initSlackChannels() {
  SLACK_CHANNELS.each { key, value ->
      withCredentials([usernamePassword(credentialsId: value.channel,
                   passwordVariable: 'channel_token',
                   usernameVariable: 'channel_name')]) {
                     value.channel="#$channel_name"
                     value.token="$channel_token"
                     echo "channel_token is '${channel_token}'"
		                 echo "channel_name is '${channel_name}'"
                   }
  }
}

// slack notification
// channel - "pipeline", "po" or "gate_keeper"
// msg - string
// color - "good", "danger" , may need more work
def slackNotification(channel,msg,color,nc) {
    def lt,lc

    lt=SLACK_CHANNELS[channel].token
    lc=SLACK_CHANNELS[channel].channel

    slackSend color: color, channel: lc, message: msg, baseUrl: SLACK_URL, token: lt, notifyCommitters: nc
}

//get vulnerability assessment information from cloud registry scan
def getVulnerabilityInfo(fullImageSpec,full_version) {
  withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {

      echo "Pulling vulnerability assessment information from AWS ECR Cloud Registry..."
      def imageTag="${full_version}"

      try {

           	sh 'aws ecr get-login-password --region us-west-2'


	  	// wait for scan every 5 seconds 60 times.   Returns 255 on failure
	  	def COUNT = sh returnStdout: true, script: "aws ecr wait image-scan-complete --repository-name ${fullImageSpec} --image-id imageTag=${imageTag} --region us-west-2 | tr -d '\n'"
	  	echo "COUNT : ${COUNT}"

	    // 255 means the scan did not complete in 5 minutes
	  	if ((COUNT != "255")) {
			echo 'Found report'
	  		sh "aws ecr describe-image-scan-findings --repository-name ${fullImageSpec} --image-id imageTag=${imageTag} --region us-west-2  --output text | tee devops/ecr_${fullImageSpec}_report.txt"

	  	} else {

	    		echo "Vulnerability scan has taken more then 5 minutes" > devops/ecr_report.txt

	  	} // end if-else
          publishHTML (target: [
              allowMissing: true,
              alwaysLinkToLastBuild: false,
              keepAll: false,
              reportDir: 'devops',
              //reportFiles: 'ecr_report.txt,npm_audit.html',
              reportFiles: 'ecr_"${fullImageSpec}"_report.txt',
              reportName: "Vulnerability Assessment Report"
            ])
        }

      catch(Exception e) {
        echo "Scan failed to complete. Please try again later."
        echo e.toString()
      }
  }
}

//Write version info to version.txt and push to git hub.
def writeversioninfo() {

  withCredentials([usernamePassword(credentialsId: "${GITHUB_CREDS_ID}", usernameVariable: 'NUSER', passwordVariable: 'NPASS')]) {
    
    echo "Inside the job tmp directory."
    echo pwd()
      
    git(url: "https://${GIT_HOST}/${GIT_GROUP}/${GIT_DEPLOYMENT_REPO_NAME}.git",credentialsId: "Github",branch: "master") 
      
    def version_data=""
    //File file = new File("devops/versions.txt")
    //def firstwrite="n"
    echo "g_result : ${g_results}"
    
    for (String g : g_results) {
      version_data=version_data+"${g}\n"
    }
    
    writeFile(file: 'devops/versions.txt', text: version_data)
   
    sh """
      cat devops/versions.txt
      git status
        
      git add devops/versions.txt
        
      git commit -m "versions.txt for ${g_results})"
      echo "${GIT_HOST}/${GIT_GROUP}/${GIT_DEPLOYMENT_REPO_NAME}"
      git push -f https://${NUSER}:${NPASS}@${GIT_HOST}/${GIT_GROUP}/${GIT_DEPLOYMENT_REPO_NAME}.git
    """
      
  }
}
//
// Get the version for the containers from ECR.
//
def getallversions() {
  withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-ecr', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {

    //login in the ecr
    sh """
      aws ecr get-login-password --region us-west-2
    """  
              
    def containerline=""
    def result=[]
    def version=""
    def containerlist = ["dotnetsample","cammissample","cammiscloud","cammisbuildah","cammisterraform","cammisboto3"]
              
    for (String e : containerlist) {
              
      // get version info.
      version= sh returnStdout: true, script: "aws ecr describe-images --repository-name ${e} --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' | tr -d '\n' "
      echo "version after: ${version}"
      version = version.toString().replaceAll('\\"','')	
                
      if ( version == "latest" ) {
        echo "version before : ${version}"
        version= sh returnStdout: true, script: "aws ecr describe-images --repository-name ${e} --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[1]' | tr -d '\n' "
        echo "version after: ${version}"
        version = version.toString().replaceAll('\\"','')	
        containerline = e+":"+"${version}"
        g_results.add(containerline)
        containerline = '"'+containerline+'"'
        result.add(containerline)
                   
        }
      else {
        //version = version.toString().replaceAll('\\"','')	
        containerline = e+":"+"${version}"
        g_results.add(containerline)
        containerline = '"'+containerline+'"'
        result.add(containerline)
      }
              
      env_versionList = result
      echo "env_versionList: ${env_versionList}"
      echo "g_result: ${g_results}"
                       
    }  // End for         
  } // END With
}  // END Script